---
title: 录像配置
permalink: /docs/zh/config-record
key: docs-2.7-config-record-zh
---

## TS录像

### live_record

*Syntax:* `live_record on|off`  
*Context:* rtmp, server, application  

* **Desc**  
    > 录像功能开关，开启后将在指定目录存储直播内容文件（ts格式）  
    > `默认值：off`{:.info}

* **For example**  
    ```nginx
    live_record on;
    ```

---

### live_record_path
*Syntax:* `live_record_path path`  
*Context:* rtmp, server, application  

* **Desc**  
    > 录像根目录，将在该目录下生成ts文件。  
    > `默认值为空，必须显示配置`{:.error}

* **For example**  
    ```nginx
    live_record_path /data/record;
    ```

---

### live_record_interval
*Syntax:* `live_record_interval time`  
*Context:* rtmp, server, application  

* **Desc**  
    > 录制过程中重新打开索引文件和ts文件的时间间隔。  
    `默认值：600s`{:.info}

* **For example**  
    ```nginx
    live_record_interval 60s;
    ```

### live_record_min_fragment
*Syntax:* `live_record_min_fragment time`  
*Context:* rtmp, server, application  

* **Desc**  
    > 录制过程中索引文件里记录的最小分片大小。  
    `默认值：8s`{:.info}

* **For example**  
    ```nginx
    live_record_min_fragment 8s;
    ```

---

### live_record_max_fragment

*Syntax:* `live_record_max_fragment time`  
*Context:* rtmp, server, application  

* **Desc**  
    > 录制过程中索引文件里记录的最大分片大小。  
    `默认值：12s`{:.info}

* **For example**  
    ```nginx
    live_record_max_fragment 12s;
    ```

### live_record_buffer
*Syntax:* `live_record_buffer value`  
*Context:* rtmp, server, application

* **Desc**  
    > 录制过程中数据缓冲大小。  
    `默认值 1024*1204`{:.info}

* **For example**  
    ```nginx
    live_record_buffer 1048576;
    ```

---  
---

## flv录像

### record

*Syntax:* `record [off|all|audio|video|keyframes|manual]`  
*Context:* rtmp, server, application, recorder

* **Desc**  
    > flv录像开关，可以是以上任意的组合。  
    > off - 不开启录像  
    > all - 录音频和视频  
    > audio - 只录音频  
    > video -  只录视频  
    > keyframes - 只录关键帧视频  
    > manual - 不自动开始录制，需要通过control接口控制开启。  
    > `默认值：off`{:.info}

* **For example**  
    ```nginx
    record all;
    ```

    或  

    ```nginx
    record audio keyframes;
    ```

---
 
### record_path
*Syntax:* `record_path path`  
*Context:* rtmp, server, application, recorder

* **Desc**  
    > FLV文件的存放路径。  
    > `默认值空，必须显示配置`{:.error}

* **For example**  
    ```nginx
    record_path /tmp/rec;
    ```

---

### record_suffix
*Syntax:* `record_suffix value`  
*Context:* rtmp, server, application, recorder

* **Desc**  
    > 设置录像文件的后缀。  
    > `默认：.flv`{:.info}

* **For example**  
    ```nginx
    record_suffix   _recorded.flv;
    ```

    - 后缀可以strftime格式的模式，如下：
    ```nginx
    record_suffix -%d-%b-%y-%T.flv;
    ```
    > 将产生的形式mystream-24-Apr-13-18:23:38.flv 的录像文件。  
    > 所有支持的strftime格式选项都可以在strftime手册页上找到。

---

### record_unique
*Syntax:* `record_unique on|off`  
*Context:* rtmp, server, application, recorder

* **Desc**  
    > 如果打开，则将当前时间戳添加到录制的文件名中。否则，每次进行新录制时都会重写相同的文件。  
    > `默认：off`{:.info}

* **For example**  
    ```nginx
    record_unique on;
    ```

---

### record_append
*Syntax:* `record_append on|off`  
*Context:* rtmp, server, application, recorder

* **Desc**  
    > 切换文件追加模式。打开记录器后，会将新数据追加到旧文件中，或者在丢失时创建新数据。文件中的旧数据和新数据之间没有时间间隔。  
    > `默认：off`{:.info}

* **For example**  
    ```nginx
    record_append on;
    ```

---

### record_lock
*Syntax:* `record_lock on|off`  
*Context:* rtmp, server, application, recorder

* **Desc**  
    > 打开时，当前记录的文件将通过fcntl调用锁定。可以从其他地方进行检查以找出正在记录的文件。  
    > `默认：off`{:.info}

* **For example**  
    ```nginx
    record_lock on;
    ```
    - 在FreeBSD上，您可以使用flock工具进行检查。在Linux上，flock和fcntl是无关的，因此您只需编写一个简单的脚本来检查文件锁定状态。这是一个脚本isunlocked.py的示例。
    ```python
    #!/usr/bin/python

    import fcntl, sys

    sys.stderr.close()
    fcntl.lockf(open(sys.argv[1], "a"), fcntl.LOCK_EX|fcntl.LOCK_NB)
    ```

---

### record_max_size
*Syntax:* `record_max_size size`  
*Context:* rtmp, server, application, recorder

* **Desc**  
    > 设置最大录像文件大小，如果为0则表示不作限制。  
    > `默认：0`{:.info}

* **For example**  
    ```nginx
    record_max_size 128K;
    ```

---

### record_max_frames
*Syntax:* `record_max_frames nframes`  
*Context:* rtmp, server, application, recorder

* **Desc**  
    > 设置每个录制文件的最大视频帧数，如果为0则表示不作限制。  
    > `默认值：0`{:.info}

* **For example**  
    ```nginx
    record_max_frames 2;
    ```

---

### record_interval
*Syntax:* `record_interval time`  
*Context:* rtmp, server, application, recorder

* **Desc**  
    > 在指定多少毫秒或秒后重新开始录制。零表示录制之间没有延迟。如果record_unique关闭，则所有录像片段都将写入同一文件。否则，将附加时间戳，这会使文件不同（给定record_interval大于1秒）。  
    > `默认：0s`{:.info}

* **For example**  
    ```nginx
    record_interval 1s;
    ```

---

### recorder
*Syntax:* `recorder name {...}`  
*Context:* application

* **Desc**  
    > 创建记录器块（block）。可以在单个`application`中创建多个record。可以在recorder {}块中指定所有上述与记录有关的配置。所有设置都继承自更高级别的配置。
    > `默认空，需要显示配置`{:.error}

* **For example**  
    ```nginx
    application {
        live on;
    
        # default recorder
        record all;
        record_path /var/rec;
    
        recorder audio {
            record audio;
            record_suffix .audio.flv;
        }
    
        recorder chunked {
            record all;
            record_interval 15s;
            record_path /var/rec/chunked;
        }
    }
    ```